
Based on the prompt engineering techniques from your course material, the key to getting great results is to be highly specific , use step-by-step instructions , and encourage the LLM to plan before writing code. We will also use the concept of a checklist for the coding phase to keep the LLM focused.

Here are the upgraded, highly detailed prompts for your Coding LLM (like Cursor or Claude):

### Phase 1: Requirements Engineering Prompt

Technique used: Be specific and use step-by-step instructions.

**Copy & Paste this:**

 Act as an Expert Requirements Engineer. We are building a single-page web application for a university project.
 
 
 **The Product:** A "Unit Test Generator". The problem is that developers often lack the time to write comprehensive tests. Our solution is an app where the user pastes a JavaScript/TypeScript function, and the application generates a complete test suite for it using Vitest. The generated tests must include standard cases, edge cases, partition testing, and guideline-based testing.
 
 
 **Constraints:**
 * The application must be single-page.
 * It must run locally on localhost (no deployment).
 * It must support English only.
 
 
 **Your Task:**
 Please generate the documentation for "Phase 1: Requirements Engineering".
 Follow these steps exactly:
 1. Write a clear, bulleted list of Functional Requirements for this specific feature.
 2. Write a clear, bulleted list of Acceptance Criteria, ensuring they cover the UI interaction, the backend processing, and the output display.
 3. Keep the language concise and professional, without unnecessary storytelling.
 
 

---

### Phase 2: Architecture Prompt

Technique used: Let the LLM explore and plan before generating the final output.

**Copy & Paste this:**

 Act as a Senior Software Architect. We are moving to "Phase 2: Architecture" for our Unit Test Generator web application.
 
 
 **Context & Tech Stack:**
 * Frontend: React.js (Vite).
 * Backend: Node.js.
 * Testing Framework for output: Vitest.
 * **CRITICAL LLM ROLE:** We must use the Gemini API as our "Feature LLM" (Application LLM). This means our Node.js backend will send the user's code to Gemini, and Gemini will generate the actual unit test code.
 
 
 
 
 **Your Task:**
 First, think step-by-step and outline a plan for how the frontend, backend, and Gemini API will interact.
 Once you have planned it, generate the official Architecture documentation section for our README. It must include the following specific sections:
 1. **Overall architecture:** A brief explanation of the client-server model used. 2. **Technology stack:** Listing React Vite, Node.js, and Vitest. 3. **Frontend/backend responsibilities:** What the React app does vs. what the Node server does. 4. **LLM integration model:** Specifically detailing how Node.js communicates with the Gemini API. 5. **Data flow:** Step-by-step flow from user input to the displayed test result. 6. **File structure:** A proposed tree structure for the project. 7. **Third-party libraries:** Any necessary packages (e.g., Axios, Google Generative AI SDK). 
 
 

---

### Phase 3: Coding & Testing Prompt

Technique used: Use Checklists & Scratchpads to guide the LLM through a multi-step task without losing focus , and implement a Test/Code workflow.

**Copy & Paste this:**

 Act as a Full-Stack Developer and QA Automation Engineer. We are now in "Phase 3: Coding & Testing".
 
 
 We need to build the Unit Test Generator (React Vite frontend, Node.js backend, Gemini API integration) and test it.
 **Instructions - Follow this Checklist exactly:**
 **Step 1: Backend Implementation**
 Write clean, well-organized Node.js code for the backend API. Create an endpoint that accepts a code string, constructs a prompt asking to generate Vitest unit tests (instructing the inclusion of mock objects and exception testing via `assertThrows` or equivalent), and calls the Gemini API.
 
 
 **Step 2: Frontend Implementation**
 Write the React (Vite) code. Create a simple UI with a text area for input, a submit button, and a display area for the generated code. Ensure the code follows standard conventions.
 
 
 **Step 3: README Documentation**
 Create a markdown table with two columns: "File Name" (clickable links) and "Description". Only include the key files we just created.
 
 
 **Step 4: System Testing (Playwright)**
 Do NOT generate LLM interaction logs for this step. Write one meaningful automated system-level functional test using Playwright. The test must automate this real user flow:
 
 
 * Navigate to the app.
 * Paste a dummy JavaScript function into the input.
 * Click the generate button.
 * Wait for the API response.
 * Assert that the generated test code is visible on the screen.
 Add a brief comment block explaining what is tested and why it is a meaningful system test.
 
 -----